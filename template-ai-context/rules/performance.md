# 성능 최적화 가이드

## 모델 선택 전략

### Haiku 4.5

Sonnet 대비 90% 성능, 3배 비용 절감

**사용 시기**:
- 가벼운 에이전트 (빈번한 호출)
- 페어 프로그래밍, 코드 생성
- 멀티 에이전트 시스템의 워커 에이전트
- 간단한 파일 검색, 포맷팅

### Sonnet 4.5

최고의 코딩 모델

**사용 시기**:
- 주요 개발 작업
- 멀티 에이전트 워크플로우 오케스트레이션
- 복잡한 코딩 태스크
- 코드 리뷰, 리팩토링

### Opus 4.5

가장 깊은 추론 능력

**사용 시기**:
- 복잡한 아키텍처 결정
- 최대 추론이 필요한 작업
- 연구 및 분석 태스크
- 시스템 설계

## 컨텍스트 윈도우 관리

### 컨텍스트 마지막 20% 회피

다음 작업은 컨텍스트 여유가 충분할 때 수행:

- 대규모 리팩토링
- 여러 파일에 걸친 기능 구현
- 복잡한 상호작용 디버깅

### 컨텍스트 민감도가 낮은 작업

컨텍스트가 부족해도 수행 가능:

- 단일 파일 편집
- 독립적인 유틸리티 생성
- 문서 업데이트
- 간단한 버그 수정

## Ultrathink + Plan Mode

복잡한 작업에 깊은 추론이 필요할 때:

1. **ultrathink** 사용하여 향상된 사고
2. **Plan Mode** 활성화하여 구조화된 접근
3. 여러 라운드의 비평으로 "엔진 예열"
4. 다양한 분석을 위한 역할 분리 서브 에이전트 사용

## 빌드 문제 해결

빌드 실패 시:

1. **build-error-resolver 에이전트** 사용
2. 에러 메시지 분석
3. 점진적으로 수정
4. 각 수정 후 검증

```bash
# 빌드 실행
./gradlew clean build

# 실패 시 에러 분석 후 수정
# 단계별로 검증
./gradlew compileKotlin
./gradlew test
./gradlew build
```

## 효율적인 작업 패턴

### 병렬 처리 활용

```markdown
# Good - 독립적인 작업 병렬 실행
동시에 실행:
- 모듈 A 테스트
- 모듈 B 린트 검사
- 모듈 C 빌드

# Bad - 불필요한 순차 실행
모듈 A 테스트 → 모듈 B 린트 → 모듈 C 빌드
```

### 점진적 검증

```bash
# 전체 빌드 대신 단계별 검증
./gradlew ktlintCheck      # 1. 린트
./gradlew compileKotlin    # 2. 컴파일
./gradlew test             # 3. 테스트
./gradlew build            # 4. 전체 빌드
```

### 캐시 활용

```bash
# Gradle 캐시 활용 (clean 없이)
./gradlew build

# 캐시 무효화가 필요한 경우만
./gradlew clean build
```

## 모델별 추천 사용처

| 작업 | 추천 모델 |
|------|----------|
| 간단한 파일 수정 | Haiku |
| 코드 리뷰 | Sonnet |
| 새 기능 구현 | Sonnet |
| 아키텍처 설계 | Opus |
| 버그 수정 | Sonnet |
| 문서 작성 | Haiku |
| 복잡한 리팩토링 | Opus |
| 테스트 작성 | Sonnet |
