### 증강 코딩의 철학
증강 코딩은 개발자의 사고, 판단, 설계를 AI로 대체하는 것이 아니라, 증폭(amplify)시키는 방식이다.
- AI는 결정권자가 아니다.
- AI는 사고를 빠르게 드러내주는 거울이다.
- 코드는 여전히 사람의 책임이다.
- 즉, "AI가 짜줬으니 맞겠지." 가 아닌, "AI로 내 생각을 더 빨리 검증하자." 이다.

### 바이브 코딩과의 비교

| 구분    | 바이브 코딩 | 증강 코딩      |
|-------|--------|------------|
| 중심    | 결과     | 사고 과정      |
| AI 역할 | 대리인    | 보조 사고 장치   |
| 실패    | 숨김     | 드러냄        |
| 코드    | 블랙박스   | 설명 가능한 산출물 |

내가 인지하는 바이브 코딩의 흐름

1. 느낌으로 요구사항을 던진다.
2. 결과물을 보고, 오- 괜찮은데? 한다.
3. 왜 되는지, 왜 실패하는지의 중요성이 떨어진다.

### 켄트벡 사상과의 연관성

증강 코딩은 **Kent Beck**의 사상과 매우 밀접하다.

TDD의 본질은 테스트가 아니다.

> "지금 내가 무엇을 모르고 있는가?" 를 가장 작은 단위로 드러내는 행위

증강 코딩은 이 질문을 AI와 함께 더 빨리 반복한다.

- 테스트 -> 질문
- AI 응답 -> 가설
- 코드 -> 검증

Tidy First?

- 행동 변경(behavior change)과 구조 변경(structural change)을 분리한다.

### 논리실증주의와의 연관성

증강 코딩은 철학적으로 보면 **논리실증주의(Logical Positivism)** 와 닮아 있다.

핵심 원칙 하나만 보면 된다.

> 검증 불가능한 명제는 의미가 없다
- "이게 더 좋아 보여요" -> X
- "아마 이게 맞을 거예요" -> X
- "이 테스트가 통과하면, 이 가설은 일단 유효합니다" -> O

> 증강 코딩은 느낌을 명제로 바꾸고, 명제를 코드로 바꾸는 과정이다.

### 핵심 원칙

1. 질문이 먼저다

   코드는 답이고, **질문이 설계**다.

2. AI는 ‘정답기’가 아니다

   AI에게 요구하지 말고 대화하라. "이 로직의 전제가 뭐라고 생각해?"

3. 항상 작게 시작한다
    1. 작은 테스트
    2. 작은 함수
    3. 작은 책임
4. 설명할 수 없는 코드는 거짓이다

   AI에게 설명시켜라. 설명이 이상하면 코드도 이상하다.

5. 실패를 숨기지 않는다

   에러 메시지, 테스트 실패는 **가장 가치 있는 정보**다.

6. 사람이 최종 책임자다

   AI가 짠 코드의 **모든 버그는 내 버그**다.

7. 코드는 사고의 기록이다

   "동작하는 것"보다 "왜 이렇게 생각했는가" 가 남아야 한다.


### 증강 코딩이 실무 개발자에게 맞는 이유

- 복잡한 도메인
- 잦은 변경
- 느린 테스트
- 의사결정 비용

### 마무리 질문

증강 코딩의 철학은 결국 이 질문 하나로 수렴한다.

> "이 코드는 나의 어떤 생각을 기록하고 있는가?"