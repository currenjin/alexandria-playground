### Q1. 정보 은닉이 OOP에서만 가능한 것인가?
A. 아니다. 함수형 프로그래밍의 클로저, 모듈 시스템, API 게이트웨이 등 어디서든 가능하다. 핵심은 "변경될 것을 숨기고 안정적인 것을 노출"하는 원칙이지, 특정 패러다임이 아니다.

### Q2. 누출된 추상화의 구체적 예시는?
A. (1) ORM이 SQL 예외를 그대로 전파. (2) REST API가 DB 스키마를 그대로 노출. (3) 컬렉션의 내부 구현(ArrayList vs LinkedList)에 의존하는 코드. (4) HTTP 상태 코드가 내부 에러 구조를 노출.

### Q3. "변경될 가능성이 높은 결정"을 어떻게 예측하는가?
A. (1) 외부 의존성: DB, 메시지 큐 등은 변경 가능. (2) 비즈니스 규칙: 정책은 자주 바뀜. (3) 구현 알고리즘: 최적화를 위해 교체 가능. (4) 데이터 형식: API 스키마는 진화함. 이들을 인터페이스 뒤에 숨겨야 한다.

### Q4. 추상화가 "너무 많은" 상태는 어떻게 인식하는가?
A. (1) 간단한 기능을 추가하는데 여러 추상화 계층을 거쳐야 할 때. (2) 추상화 계층이 1:1 위임만 할 때. (3) 디버깅 시 "실제 동작하는 코드"를 찾기 어려울 때. 추상화는 복잡성을 감추기 위해 존재하며, 복잡성을 추가하기 위해 존재하는 것이 아니다.

### Q5. API 설계에서 정보 은닉을 실천하는 방법은?
A. (1) 내부 ID 대신 외부 식별자 사용. (2) DB 스키마가 아닌 도메인 모델 기반 응답. (3) 에러 메시지에 내부 스택트레이스 미포함. (4) 버전관리로 내부 변경이 클라이언트에 영향 안 가게. (5) DTO로 내부 엔티티와 외부 표현 분리.
