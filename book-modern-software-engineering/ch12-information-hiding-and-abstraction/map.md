# Ch12. Information Hiding and Abstraction

## TL;DR
- **정보 은닉**은 모듈의 구현 세부사항을 외부로부터 숨기는 것이다.
- **추상화**는 복잡한 것의 핵심만 드러내고 나머지를 감추는 것이다.
- 안정적인 인터페이스를 노출하고 변동성이 큰 구현을 숨기면, **변경의 영향 범위를 최소화**한다.
- **누출된 추상화(Leaky Abstraction)**는 내부 세부사항이 외부로 새어나가는 것으로, 정보 은닉의 실패다.

## Key Ideas
- **David Parnas의 정보 은닉**: 모듈은 "변경될 가능성이 높은 결정"을 내부에 숨겨야 한다. 1972년 논문에서 제안된 원칙이 지금도 유효하다.
- **인터페이스 = 계약**: 모듈이 "무엇을 하는지"만 공개하고 "어떻게 하는지"는 숨긴다. 인터페이스가 안정적이면 내부 구현을 자유롭게 변경할 수 있다.
- **추상화 수준**: 좋은 추상화는 적절한 수준에서 복잡성을 감춘다. 너무 낮으면 세부사항에 노출되고, 너무 높으면 유연성을 잃는다.
- **누출된 추상화**: Joel Spolsky의 법칙 - "모든 비자명한 추상화는 어느 정도 누출된다." 완벽한 추상화는 없지만, 누출을 최소화하려는 노력이 필요하다.
- **캡슐화와 정보 은닉의 차이**: 캡슐화는 데이터와 행동을 묶는 것(메커니즘), 정보 은닉은 변경될 것을 숨기는 것(원칙). 캡슐화는 정보 은닉을 구현하는 수단 중 하나다.

## Trade-offs

| 선택 | 장점 | 단점 | 언제 |
|-----|-----|-----|-----|
| 엄격한 정보 은닉 | 변경 영향 최소화 | 초기 설계 비용 | 변경이 빈번한 영역 |
| 느슨한 정보 은닉 | 빠른 개발 | 변경 파급 효과 큼 | 프로토타입, 안정된 영역 |
| 높은 추상화 | 단순한 사용 | 디버깅 어려움, 성능 손실 가능 | 복잡한 내부 로직 |
| 낮은 추상화 | 제어력, 투명성 | 복잡한 사용 | 성능 크리티컬 영역 |

## Open Questions
- 코드베이스에서 "구현 세부사항이 인터페이스로 새어나간" 대표적인 사례는?
- 추상화 수준을 적절히 설정하는 기준은 무엇인가?
