# Ch03. Fundamentals of an Engineering Approach

## TL;DR
- 소프트웨어 엔지니어링의 근본은 **학습 최적화**와 **복잡성 관리** 두 가지다.
- 학습 최적화: **반복(Iteration)**, **피드백(Feedback)**, **점진주의(Incrementalism)**, **경험주의(Empiricism)**, **실험주의(Experimental)**.
- 복잡성 관리: **모듈성(Modularity)**, **응집도(Cohesion)**, **관심사 분리(SoC)**, **정보 은닉(Information Hiding)**, **결합도 관리(Coupling)**.
- 이 원칙들은 독립적이 아니라 **서로 강화**하는 관계다.

## Key Ideas
- **두 축의 균형**: 학습만 빠르면 복잡해지고, 복잡성만 관리하면 느려진다. 둘의 균형이 핵심이다.
- **학습 최적화 5원칙**: 반복 → 작은 단계로 나눔, 피드백 → 결과를 빠르게 확인, 점진주의 → 릴리즈 가능한 단위로 진행, 경험주의 → 증거 기반 판단, 실험주의 → 가설-검증 반복.
- **복잡성 관리 5원칙**: 모듈성 → 독립 단위로 분리, 응집도 → 관련 기능 집중, 관심사 분리 → 다른 문제는 다르게, 정보 은닉 → 변경 영향 격리, 결합도 관리 → 의존성 최소화.
- **실천법은 원칙의 구현**: CI/CD, TDD, 마이크로서비스 등은 이 원칙들의 구체적 실천이다.

## Trade-offs

| 선택 | 장점 | 단점 | 언제 |
|-----|-----|-----|-----|
| 학습 속도 우선 | 빠른 실험/검증 | 기술 부채 축적 가능 | 시장 불확실성 높을 때 |
| 복잡성 관리 우선 | 장기 유지보수성 | 초기 속도 저하 | 장기 운영 시스템 |
| 모든 원칙 동시 적용 | 이상적 결과 | 현실적으로 어려움 | 충분한 역량과 시간이 있을 때 |
| 점진적 원칙 도입 | 현실적, 팀 적응 가능 | 전환 기간 비일관성 | 대부분의 현실 상황 |

## Open Questions
- 우리 팀에서 가장 약한 원칙은 무엇인가?
- 학습 최적화와 복잡성 관리 중 현재 더 투자가 필요한 쪽은?
