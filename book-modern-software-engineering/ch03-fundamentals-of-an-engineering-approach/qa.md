### Q1. 학습 최적화와 복잡성 관리가 충돌할 때 어떻게 하나?
A. 빠른 실험(학습 최적화)은 종종 코드 품질을 희생(복잡성 증가)한다. 해결책은 "스파이크"(탐색용 코드)와 "프로덕션 코드"를 분리하는 것. 스파이크로 학습한 뒤, 원칙에 맞게 다시 구현한다.

### Q2. 10가지 원칙 중 가장 먼저 도입해야 할 것은?
A. **피드백**과 **반복**. 이 둘이 없으면 다른 원칙의 효과를 측정할 수 없다. 자동화된 테스트와 CI부터 시작하여 빠른 피드백 루프를 구축하는 것이 첫걸음이다.

### Q3. 실천법(Practice)과 원칙(Principle)의 관계는?
A. 원칙은 "왜"에 해당하고, 실천법은 "어떻게"에 해당한다. 예: "피드백을 빠르게"(원칙) → TDD, CI/CD(실천법). 원칙을 이해하면 상황에 맞는 실천법을 선택하거나 새로 만들 수 있다.

### Q4. 이 원칙들이 애자일과 어떻게 다른가?
A. 애자일은 주로 프로세스(스크럼, 칸반)에 초점을 맞추지만, 이 원칙들은 기술적 실천(설계, 테스트, 배포)에 초점을 맞춘다. 애자일 프로세스 없이도 이 원칙들을 적용할 수 있고, 둘을 함께 쓰면 더 효과적이다.

### Q5. "좋은 소프트웨어 설계"의 객관적 기준이 있는가?
A. Farley는 **변경 용이성**을 핵심 기준으로 제시한다. 새로운 기능을 추가하거나 버그를 수정할 때의 비용이 낮으면 좋은 설계다. 이는 모듈성, 응집도, 결합도 등으로 측정할 수 있다.
