### Q1. 타임아웃은 어떻게 설정하나요?
A. 경험칙: `timeout ≈ 2×RTT + 처리시간 + 여유`. 홉별 예산 분배(전체 SLO에서 역산). 너무 짧으면 오탐↑, 너무 길면 복구↓. 모니터링으로 p95 RTT 파악 후 조정. 모노토닉 클럭 사용.

### Q2. 재시도는 언제/어떻게 해야 하나요?
A. 멱등 작업에만. 지수 백오프+지터(동시 재시도 분산). Retry Budget(예: ≤5%)으로 증폭 방지. 서킷브레이커와 조합. 비멱등 작업은 큐/워크플로로 전환.

### Q3. Retry Budget이란 무엇인가요?
A. 일정 기간 내 재시도 비율 상한. 예: "최근 1분 요청 중 재시도 5% 이하". 초과 시 재시도 중단, 즉시 실패 반환. 장애 시 재시도 폭증(Retry Storm) 방지. 서비스별/경로별 설정.

### Q4. 헤지드 요청(Hedged Request)이란 무엇인가요?
A. p95 등 임계 시간 초과 시 동일 요청을 다른 서버에 병렬 전송, 먼저 온 응답 사용. Tail latency 절단. 조건: 중복 안전(멱등), 부하 여유. 무조건 헤지는 부하 2배 → 조건부로.

### Q5. 분산 시스템에서 시계를 왜 신뢰하면 안 되나요?
A. NTP 동기화 지연, 클럭 드리프트, VM 일시정지 등으로 수십ms~수초 오차 가능. 이벤트 순서 판단, 타임아웃에 wall-clock 사용 위험. 지연 측정은 모노토닉 클럭, 순서는 버전/시퀀스 사용.

### Q6. 펜싱 토큰(Fencing Token)이란 무엇인가요?
A. 리스/락 획득 시 발급되는 단조 증가 토큰. 저장소가 토큰 검증 → 구 리더의 지연된 쓰기 거부. 클럭 스큐/GC 스톨로 리스 만료 모르는 좀비 리더 방어. 락 만으로 불충분, 펜싱 필수.

### Q7. Failure Detector는 어떻게 설계하나요?
A. 하트비트 + 타임아웃 기반. φ-accrual: 지연 분포 학습, 의심 점수 산출. 공격적(빠른 차단, 오탐↑) vs 보수적(정확, 느림) 조절. 핵심 경로는 공격적, 비핵심은 보수적.

### Q8. Exactly-once 전달은 가능한가요?
A. 네트워크 레벨에서 불가능. 응답 유실 시 전송 성공 여부 모름. 실용적 해법: At-least-once + 소비자 멱등성 = "효과적 exactly-once". 멱등키, 시퀀스 번호, 중복 제거 스토어로 구현.
