## 기초

### Q1. 트랜잭션의 핵심 가치는?
A. 애플리케이션이 지켜야 할 불변식을 데이터베이스 레벨에서 보호해 준다는 점이다. 실패/동시성 상황에서도 일관성을 유지한다.

### Q2. 격리 수준은 왜 중요한가요?
A. 어떤 이상 현상을 허용할지 결정한다. 성능과 정확성 사이의 계약이므로 기본값을 맹신하면 안 된다.

### Q3. Serializable은 언제 필요하나요?
A. 금액, 재고, 중복 방지처럼 불변식 위반 비용이 큰 경로에서 필요하다. 모든 경로에 적용하면 지연/충돌 비용이 커질 수 있다.

## 실무

### Q4. Write skew를 운영에서 어떻게 잡나요?
A. 문제 경로를 재현 가능한 동시성 테스트로 만들고, 필요 시 잠금 또는 직렬화 격리를 적용한다. 로그만으로는 원인 규명이 어렵다.

### Q5. 2PC 대신 SAGA를 쓰는 기준은?
A. 서비스 경계가 많고 장기 작업이 포함될수록 SAGA가 현실적이다. 대신 보상 트랜잭션과 멱등성을 설계해야 한다.

### Q6. 멱등키 저장소는 Redis와 RDB 중 무엇이 낫나요?
A. 고QPS 단기 중복 차단은 Redis, 감사/영속성이 중요하면 RDB가 낫다. 실무에서는 Redis + 주기적 백업 혼합도 많다.

## 면접

### Q7. "트랜잭션은 느리니 최소화해야 한다"는 주장에 대한 의견은?
A. 무조건 줄이는 게 아니라, 불변식 보호가 필요한 경로에 정확히 써야 한다. 잘못 줄이면 애플리케이션 복잡도와 장애 비용이 더 커진다.

### Q8. 교착 상태를 설계로 예방하는 방법은?
A. 락 획득 순서를 전역 규칙으로 통일하고, 트랜잭션 범위를 최소화한다. 예방 규칙이 없으면 운영에서 반복적으로 발생한다.

### Q9. 결제-주문 연동에서 권장 패턴은?
A. 로컬 트랜잭션 + Outbox + 비동기 소비 + 보상 흐름이 일반적이다. 강결합 2PC는 장애 전파 범위를 키운다.
