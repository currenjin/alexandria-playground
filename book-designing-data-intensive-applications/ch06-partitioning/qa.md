### Q1. 파티션 키는 어떻게 선택하나요?
A. 접근 패턴 분석 → 가장 빈번한 쿼리의 WHERE 조건. 균등 분산(해시)과 범위 쿼리(키 범위) 중 우선순위 결정. 복합 키로 둘 다 달성 가능(예: user_id로 파티션, timestamp로 정렬).

### Q2. 핫스팟(Hot Spot)은 어떻게 해결하나요?
A. 핫 키에 랜덤 접두사/접미사 추가(fan-out), 읽기 시 여러 파티션 병합. 애플리케이션 레벨 분산(유명인 키 특별 처리). 시계열은 시간+ID 복합 키로 최근 데이터 분산.

### Q3. 해시 파티셔닝에서 범위 쿼리는 어떻게 하나요?
A. 순수 해시로는 범위 쿼리 불가(scatter-gather 필수). 복합 키 사용: 첫 번째 컬럼으로 파티션(해시), 두 번째 컬럼으로 정렬. 예: (user_id, created_at) → user별 시간 범위 쿼리 가능.

### Q4. 보조 인덱스와 파티셔닝의 관계는?
A. 로컬 인덱스: 각 파티션에 자체 인덱스. 쓰기 빠름, 읽기 시 모든 파티션 조회(scatter-gather). 글로벌 인덱스: 인덱스도 파티셔닝. 읽기 빠름, 쓰기 시 분산 갱신 필요(비동기 지연 가능).

### Q5. 리밸런싱은 언제/어떻게 하나요?
A. 노드 추가/제거, 데이터 증가, 부하 불균형 시. 전략: 고정 파티션 수(노드 추가 시 재할당만), 동적 분할(크기 기준 분할/병합), 노드 비례(노드당 고정 수). 무중단: 백그라운드 복사 → 스위치.

### Q6. Consistent Hashing이란 무엇인가요?
A. 해시 링에 노드와 키 배치, 키는 시계방향 첫 노드에 할당. 노드 추가/제거 시 인접 키만 이동(전체 재배치 방지). 가상 노드로 균등 분산 개선. Dynamo, Cassandra 등에서 사용.

### Q7. 파티션 수는 몇 개로 설정하나요?
A. 너무 적으면 핫스팟/리밸런싱 불균형, 너무 많으면 오버헤드↑. 경험칙: 예상 최대 노드 수의 10배 이상. 예: 최대 10노드 예상 → 100~256 파티션. 고정 파티션이면 미래 성장 고려.

### Q8. Cross-partition 쿼리/트랜잭션은 어떻게 처리하나요?
A. 가능하면 피함(파티션 키 포함 쿼리 설계). 불가피하면: scatter-gather(병렬 조회 후 병합), 2PC(분산 트랜잭션, 비용↑), SAGA(보상 트랜잭션). 파티션 키 설계가 핵심.
