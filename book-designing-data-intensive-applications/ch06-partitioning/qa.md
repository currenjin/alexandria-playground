## 기초

### Q1. 파티셔닝의 목적은 무엇인가요?
A. 데이터와 트래픽을 분산해 저장 용량과 처리량을 수평 확장하는 것이다. 단일 노드 한계를 넘기 위한 핵심 기법이다.

### Q2. 해시 파티셔닝과 범위 파티셔닝 차이는?
A. 해시는 분산이 균등하고, 범위는 순차/범위 조회에 유리하다. 대신 범위 방식은 핫스팟 위험이 크다.

### Q3. 핫 파티션은 왜 생기나요?
A. 인기 키 집중, 시간 편향 트래픽, 불균형한 키 분포 때문에 생긴다. 설계 시점의 키 선택이 가장 큰 원인이다.

## 실무

### Q4. 파티션 키를 검증하는 방법은?
A. 실제 트래픽 샘플로 키 분포를 시뮬레이션하고, 상위 1% 키가 차지하는 비율을 본다. 배포 전 검증이 운영 리스크를 크게 줄인다.

### Q5. 리밸런싱 중 장애를 줄이는 방법은?
A. 점진 이동(스로틀), 읽기/쓰기 경로 분리, 상태 전환 가시화가 필요하다. 한 번에 대량 이동하면 지연 급증과 타임아웃을 유발한다.

### Q6. cross-partition 트랜잭션은 어떻게 최소화하나요?
A. 같은 업무 단위를 같은 키 공간에 배치하도록 도메인 키를 재설계한다. 분산 트랜잭션은 마지막 수단으로 남긴다.

## 면접

### Q7. "파티션 수를 많이 잡으면 미래 확장에 무조건 유리하다"는 말의 한계는?
A. 메타데이터/연결/스케줄링 오버헤드가 커진다. 과도한 파티션은 운영 복잡도와 비용을 올린다.

### Q8. 주문 시스템에서 좋은 파티션 키 예시는?
A. `tenant_id + order_id`처럼 테넌트 격리와 균등 분산을 함께 고려한 키가 실무적으로 안전하다.

### Q9. 파티셔닝 설계에서 가장 먼저 문서화할 것은?
A. "이 쿼리는 단일 파티션으로 해결 가능한가"를 명시한 접근 패턴 목록이다. 이 문서가 없으면 쿼리 복잡도가 빠르게 폭증한다.
