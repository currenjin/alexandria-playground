### Q1. 동기 복제와 비동기 복제는 언제 각각 선택하나요?
A. 동기: 데이터 손실 불가(금융, 결제). 팔로워 확인 후 응답 → 지연↑, 가용성↓. 비동기: 대부분의 읽기 복제본. 리더 즉시 응답 → 지연↓, failover 시 데이터 손실 가능. 반동기(1개만 동기)로 절충.

### Q2. Failover 시 데이터 손실은 어떻게 방지하나요?
A. 동기 복제로 최소 1개 팔로워 보장, RPO(복구 목표점) 정의, 비동기면 손실 허용 범위 명시. Failover 후 옛 리더 복귀 시 충돌 데이터 처리 정책(버림/병합) 필요.

### Q3. 스플릿 브레인(Split Brain)이란 무엇인가요?
A. 네트워크 파티션으로 두 노드가 각각 자신이 리더라고 판단, 동시에 쓰기 받는 상태. 데이터 불일치/손실 유발. 방지: 펜싱(STONITH), 정족수 기반 리더 선출, 외부 조정자(ZooKeeper).

### Q4. Read-your-writes 일관성은 어떻게 보장하나요?
A. 쓰기 직후 읽기를 리더로 라우팅, 또는 복제 지연이 특정 시점 이하인 팔로워만 사용. 세션 스티키(같은 사용자 같은 노드), 타임스탬프 기반 라우팅. 다중 디바이스면 더 복잡.

### Q5. 다중 리더(Multi-leader) 복제는 언제 쓰나요?
A. 지리 분산(대륙별 리더), 오프라인 클라이언트(모바일 앱), 협업 앱(동시 편집). 쓰기 충돌 해결 필수. 단일 데이터센터에서는 복잡도 대비 이점↓, 권장 안 함.

### Q6. 쓰기 충돌 해결 전략(LWW, CRDT 등)은 어떻게 선택하나요?
A. LWW(Last Write Wins): 단순, 데이터 손실 감수. 멱등 작업에 적합. CRDT: 자동 병합 가능 자료구조(카운터, 집합), 복잡하지만 손실 없음. 커스텀 병합: 도메인 로직 필요(장바구니 합치기 등).

### Q7. 복제 지연(Replication Lag)은 어떻게 모니터링하나요?
A. `SHOW SLAVE STATUS`(MySQL), `pg_stat_replication`(PostgreSQL) 등 DB 제공 메트릭. 지연 시간(초), 지연 바이트, 지연 트랜잭션 수 추적. 임계치 초과 시 알람, 읽기 라우팅 조정.

### Q8. 리더리스(Leaderless) 복제는 언제 쓰나요?
A. 높은 가용성 요구, 단일 장애점 제거 필요 시. 정족수(W+R>N)로 일관성 확보. Dynamo 스타일(Cassandra, Riak). 단점: 읽기/쓰기 복잡, 충돌 해결 필요, 트랜잭션 어려움.
