# Ch09 Consistency and Consensus

## TL;DR (3문장)
- **일관성 모델**은 시스템이 보장하는 약속이다. 선형성(Linearizability)은 가장 강하지만 가용성/지연 비용이 크다.
- **합의(Consensus)** 는 분산 시스템에서 노드들이 하나의 값에 동의하는 문제다. 리더 선출, 원자적 커밋의 기반.
- FLP 불가능성으로 비동기 시스템에서 완벽한 합의는 불가능. **타임아웃과 리더 기반 프로토콜(Raft, Paxos)**로 실용적 해결.

## Key Ideas
- **일관성 모델 스펙트럼**
  - **선형성(Linearizability)**: 모든 연산이 단일 복사본처럼 동작. 최신 쓰기 보장.
  - **순차 일관성(Sequential)**: 전역 순서 존재, 실시간 순서는 보장 안 함.
  - **인과 일관성(Causal)**: 인과 관계만 보존. 동시 쓰기는 순서 미정.
  - **최종 일관성(Eventual)**: 결국엔 수렴. 중간 상태 비일관 허용.
- **선형성 비용**: CAP 정리. 네트워크 파티션 시 선형성↔가용성 택일.
- **인과 일관성과 전체 순서**
  - 인과 순서는 부분 순서(partial order)
  - 전체 순서(total order)는 선형성 또는 합의로 달성
- **Lamport 타임스탬프**: 인과 순서 추적. 전체 순서 아님(동시 이벤트 구분 불가).
- **전체 순서 브로드캐스트**: 모든 노드가 같은 순서로 메시지 수신. 합의와 동등.
- **합의 알고리즘**
  - **2PC**: 코디네이터 장애 시 블로킹. 실용적이지만 취약.
  - **Paxos/Raft/Zab**: 리더 기반, 과반수 합의. 리더 장애 시 재선출.
  - **PBFT**: 비잔틴 장애 허용(악의적 노드). 복잡, 느림.
- **합의 활용**
  - 리더 선출, 원자적 커밋, 분산 락, 유일 ID 생성
  - ZooKeeper, etcd: 합의 기반 코디네이션 서비스

## Trade-offs
| 선택 | 장점 | 단점 | 언제 |
|---|---|---|---|
| **선형성** | 강한 보장, 추론 쉬움 | 지연↑, 파티션 시 불가용 | 분산 락, 유일 제약, 리더 선출 |
| **인과 일관성** | 가용성↑, 지연↓ | 동시 쓰기 순서 미정 | 협업 앱, 소셜 피드 |
| **최종 일관성** | 최대 가용성/성능 | 읽기 비일관, 충돌 해결 필요 | 캐시, 읽기 복제본, DNS |
| **2PC** | 단순, 명확한 원자성 | 코디네이터 SPOF, 블로킹 | 단일 데이터센터, 짧은 트랜잭션 |
| **Raft/Paxos** | 비블로킹, 고가용 | 복잡, 리더 재선출 지연 | 메타데이터, 설정, 분산 락 |
| **외부 코디네이터(ZK/etcd)** | 검증된 구현, 운영 도구 | 추가 인프라, 의존성 | 리더 선출, 서비스 디스커버리 |

## Apply to Our Domain (Orders/Dispatch)
- **분산 락(배차 동시성 제어)**
  - 선형성 필요: 동시에 같은 배차 슬롯 할당 방지
  - 구현: Redis Redlock(주의: 선형성 보장 약함) 또는 ZooKeeper/etcd 분산 락
  - 펜싱 토큰 필수: 락 획득 시 토큰 발급, 저장소에서 토큰 검증
- **리더 선출(배차 워커)**
  - etcd 리스(lease) 기반 리더 선출
  - 리더 장애 시 자동 재선출, 리스 만료 > 클럭 스큐
- **주문 번호 유일성**
  - 선형성 필요: DB UNIQUE 제약 또는 합의 기반 ID 생성기
  - Snowflake ID: 타임스탬프+노드ID+시퀀스(선형성 아님, 유일성만 보장)
- **이벤트 순서(Kafka)**
  - 파티션 내 전체 순서 보장(선형성 아님)
  - 인과 일관성: 같은 파티션 키로 인과 관계 메시지 라우팅

## Metrics & SLO (30일 롤링)
### SLI
- `lock.acquire_time_ms.p95`: 분산 락 획득 시간
- `lock.contention_rate`: 락 경합 비율
- `consensus.leader_election_ms`: 리더 재선출 시간
- `consensus.commit_latency_ms.p95`: 합의 커밋 지연
- `linearizable_op.availability`: 선형성 연산 가용률

### SLO
- `lock.acquire_time_ms.p95 < 100`
- `consensus.leader_election_ms < 5000`
- `consensus.commit_latency_ms.p95 < 50`
- `linearizable_op.availability >= 99.9%`

## Open Questions
- 현재 Redis 기반 락이 **선형성을 충분히 보장**하는가? (클럭 스큐, 네트워크 파티션 시나리오)
- ZooKeeper/etcd 도입 시 **운영 복잡도**와 **가용성 향상** 트레이드오프는?
- 배차 불변식("동시 배차 ≤ N")을 **합의 기반**으로 보장할 때 지연 영향은?
- 이벤트 순서가 **인과 일관성**으로 충분한가, **전체 순서**가 필요한 경로는?

## Hands-on
### 실험 목표
- 분산 락에서 펜싱 토큰 유무에 따른 안전성 차이를 재현한다.

### 준비
- 락 서비스(etcd/ZooKeeper 또는 테스트 구현)
- 동일 자원 쓰기 경쟁 워커 2개 이상

### 실행 단계
1. 펜싱 토큰 없이 리스 기반 락으로 동시 쓰기 시나리오를 실행한다.
2. 워커 하나에 인위적 stop-the-world 지연을 주입한다.
3. 지연 복귀 워커의 늦은 쓰기 덮어쓰기 여부를 확인한다.
4. 펜싱 토큰 검증을 추가하고 동일 테스트를 반복한다.

### 검증 메트릭
- `stale_leader_write.count`
- `lock.acquire_time_ms.p95`
- `consensus.leader_election_ms`

### 실패 시 체크포인트
- stale write 1건이라도 발생하면 락 구현을 즉시 차단/교체
- 리더 선출 지연이 길면 quorum/네트워크 설정 점검
