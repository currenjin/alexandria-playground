### Q1. 선형성(Linearizability)은 언제 필요한가요?
A. 분산 락, 리더 선출, 유일 제약(중복 방지), 원자적 비교-교환. "마치 단일 복사본처럼" 동작해야 할 때. 비용: 지연↑, 네트워크 파티션 시 불가용. 필요한 경로에만 선택적 적용.

### Q2. 선형성과 직렬성(Serializability)의 차이는?
A. 선형성: 단일 객체, 실시간 순서 보장. 직렬성: 다중 객체 트랜잭션, 어떤 순서든 직렬 실행과 동등. 둘 다 강한 보장이지만 다른 차원. Strict Serializability = 둘 다 만족.

### Q3. CAP 정리를 실무에서 어떻게 적용하나요?
A. 네트워크 파티션(P)은 불가피 → C(일관성)와 A(가용성) 중 선택. 실제로는 경로별 선택: 결제는 CP(일관성 우선), 상품 목록은 AP(가용성 우선). 파티션 없을 때는 둘 다 가능.

### Q4. 합의(Consensus) 알고리즘은 왜 필요한가요?
A. 분산 시스템에서 "모든 노드가 같은 값에 동의"가 필요한 경우: 리더 선출, 원자적 브로드캐스트, 분산 락. 단순 투표로는 파티션/장애 시 불일치. Raft/Paxos가 안전하게 해결.

### Q5. ZooKeeper/etcd는 언제 쓰나요?
A. 리더 선출, 분산 락, 설정 관리, 서비스 디스커버리 등 "소량의 중요한 메타데이터"에 합의 필요 시. 대용량 데이터 저장 용도 아님. 검증된 구현으로 직접 합의 구현 위험 회피.

### Q6. 분산 락은 어떻게 구현하나요?
A. Redis SETNX(단순, 선형성 약함), Redlock(다중 노드, 논쟁 있음), ZooKeeper/etcd(합의 기반, 강함). 핵심: 펜싱 토큰 필수. 락만 믿으면 GC/네트워크 지연으로 동시 접근 가능.

### Q7. 2PC와 Raft/Paxos의 차이는?
A. 2PC: 코디네이터가 참여자에게 커밋 지시. 코디네이터 장애 시 블로킹. Raft/Paxos: 과반수 합의로 진행, 리더 장애 시 재선출. 2PC는 이기종 시스템 원자 커밋, Raft는 복제 로그 합의.

### Q8. 전체 순서 브로드캐스트(Total Order Broadcast)란?
A. 모든 노드가 같은 순서로 같은 메시지 수신 보장. 합의와 동등한 문제(상호 구현 가능). Kafka 파티션 내 순서, Raft 로그 복제가 예시. 선형성 레지스터 구현에 활용.
