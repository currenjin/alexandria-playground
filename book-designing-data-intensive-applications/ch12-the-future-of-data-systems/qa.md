### Q1. 이벤트 소싱(Event Sourcing)의 장단점은?
A. 장점: 완전한 감사 로그, 시간 여행(과거 상태 복원), 디버깅 용이, 이벤트 기반 통합. 단점: 쿼리 복잡(현재 상태 조회 어려움), 스키마 진화 어려움, 저장 비용↑. CQRS와 함께 사용.

### Q2. CQRS(Command Query Responsibility Segregation)란?
A. 쓰기(Command)와 읽기(Query) 모델 분리. 쓰기: 이벤트 저장소/정규화 DB. 읽기: 쿼리 최적화 뷰(비정규화, 검색 인덱스 등). 복잡도↑ but 각각 최적화 가능. 이벤트 소싱과 궁합 좋음.

### Q3. Lambda vs Kappa 아키텍처는 어떻게 선택하나요?
A. Lambda: 배치(정확) + 스트림(빠름) 이중 경로. 코드 중복, 유지 복잡. Kappa: 스트림만, 재처리는 리플레이. 단순, 스트림 엔진 한계 시 부적합. 스트림으로 충분하면 Kappa, 복잡한 배치 로직 필요하면 Lambda.

### Q4. CDC(Change Data Capture)는 어떻게 구현하나요?
A. DB 로그 기반(Debezium: binlog/WAL 읽기), 트리거 기반(레거시, 성능↓), 폴링 기반(타임스탬프 컬럼). 로그 기반이 가장 효율적. Kafka Connect + Debezium 조합 일반적.

### Q5. End-to-End 멱등성은 어떻게 보장하나요?
A. 클라이언트: 멱등키 생성(UUID). 서버: 키 저장(Redis/DB, TTL). 중복 요청 → 저장된 응답 반환. 이벤트 소비자: 처리 기록(offset/sequence). 외부 시스템(결제 등)도 멱등 API 활용.

### Q6. 비동기 감사(Audit)는 왜 필요한가요?
A. 동기 제약만으로는 모든 불변식 검증 불가(성능, 분산 시스템 한계). 사후 검증: 일일 배치로 잔액 불일치, 중복 레코드, 참조 무결성 검사. 위반 발견 시 알람 + 보상/수정.

### Q7. 데이터 삭제 요청(GDPR 등)은 이벤트 로그에서 어떻게 처리하나요?
A. 이벤트 로그는 불변 원칙과 충돌. 방법: Crypto shredding(암호화 후 키 삭제), 이벤트 재작성(컴팩션), Tombstone 이벤트. 설계 시 개인정보 필드 분리, 삭제 가능 구조 고려.

### Q8. "진실의 원천(Source of Truth)"은 어떻게 정하나요?
A. 각 데이터 항목에 하나의 권위 있는 저장소 지정. 다른 저장소는 파생(derived). 변경은 원천에서만, 파생은 원천에서 동기화. 충돌 시 원천 우선. 명확한 문서화 필수.
