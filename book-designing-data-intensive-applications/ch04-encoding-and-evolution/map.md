# Ch04 Encoding and Evolution

## TL;DR (3문장)
- 데이터는 **메모리(객체)** 와 **저장/전송(바이트)** 사이를 오간다. 인코딩 포맷 선택이 **호환성, 크기, 성능**을 결정한다.
- **스키마 진화**는 필수다. 전방/후방 호환성을 지키려면 **필드 추가는 optional**, **필드 제거는 신중히**, **타입 변경은 금지**.
- 데이터 흐름(DB, 서비스, 메시지)마다 호환성 요구가 다르다. **롤링 배포**를 전제로 신/구 버전 공존을 설계한다.

## Key Ideas
- **인코딩 포맷 비교**
  - JSON/XML: 사람이 읽기 쉬움, 스키마 약함, 크기↑
  - Thrift/Protocol Buffers: 바이너리, 스키마 필수, 크기↓, 전/후방 호환 설계
  - Avro: 스키마 별도 전달, reader/writer 스키마 분리, 동적 스키마 친화
- **전방 호환(Forward)**: 구 코드가 신 데이터 읽기 → 알 수 없는 필드 무시
- **후방 호환(Backward)**: 신 코드가 구 데이터 읽기 → 새 필드에 기본값
- **스키마 진화 규칙**
  - 필드 추가: optional + 기본값
  - 필드 제거: 더 이상 쓰지 않는 태그 재사용 금지
  - 타입 변경: 대부분 위험(32→64 정도만 안전)
- **데이터 흐름 패턴**
  - DB: 쓰기 시점 스키마 저장, 읽기 시점 해석(schema-on-read 포함)
  - 서비스(REST/RPC): API 버저닝, 클라이언트/서버 독립 배포
  - 메시지(큐/이벤트): 생산자/소비자 버전 불일치 허용 설계
- **롤링 배포와 호환성**: 배포 중 신/구 버전 공존. 양방향 호환 필수.

## Trade-offs
| 선택 | 장점 | 단점 | 언제 |
|---|---|---|---|
| **JSON** | 범용, 디버그 쉬움, 스키마 유연 | 크기↑, 타입 모호, 스키마 강제 어려움 | 외부 API, 설정, 로그 |
| **Protocol Buffers** | 크기↓, 스키마 명시, 전/후방 호환 | 스키마 관리 필요, 사람 읽기 어려움 | 내부 서비스 통신, 저장 |
| **Avro** | 스키마 별도, 동적 타입 친화 | 스키마 레지스트리 필요 | 데이터 파이프라인, Kafka |
| **스키마리스(JSON 자유형)** | 빠른 개발, 유연 | 런타임 오류, 진화 관리 어려움 | 프로토타입, 내부 도구 |
| **API 버저닝(URL/헤더)** | 명시적, 클라이언트 선택 | 버전 관리 복잡, 중복 코드 | 외부 API, 장기 지원 |
| **호환성 우선 진화** | 무중단 배포, 롤백 안전 | 스키마 제약, 느린 정리 | 프로덕션 시스템 |

## Apply to Our Domain (Orders/Dispatch)
- **주문 이벤트(Kafka)**: Avro + Schema Registry. 생산자/소비자 독립 배포, 스키마 진화 검증 자동화.
- **내부 서비스 통신**: gRPC/Protocol Buffers. 필드 추가는 optional, 태그 번호 재사용 금지.
- **외부 API(REST)**: JSON + OpenAPI 스키마. 버전 헤더(`Accept-Version: v2`)로 호환성 관리.
- **DB 스키마 진화**: Expand-Migrate-Contract 패턴. nullable 추가 → 백필 → NOT NULL 전환.
- **롤링 배포 체크리스트**:
  1. 신 필드 추가(optional) 배포
  2. 신 코드 배포(신 필드 쓰기/읽기)
  3. 구 필드 읽기 제거 배포
  4. 구 필드 삭제(충분한 기간 후)

## Metrics & SLO (30일 롤링)
### SLI
- `schema.compatibility.violations`: 스키마 호환성 검증 실패 수
- `api.version.usage`: API 버전별 호출 비율
- `serde.error_rate`: 직렬화/역직렬화 오류율
- `deploy.rollback_rate`: 스키마 관련 롤백 빈도

### SLO
- `schema.compatibility.violations = 0` (CI/CD 게이트)
- `serde.error_rate < 0.01%`
- `api.deprecated_version.usage < 5%` (마이그레이션 진행 지표)

## Open Questions
- 스키마 레지스트리 장애 시 **폴백 전략**은? (로컬 캐시 TTL, 서킷브레이커)
- 신규 필드 추가 후 **구 버전 소비자 비율**이 일정 이하로 떨어지는 데 걸리는 시간은?
- **필드 삭제 안전 기간**을 어떻게 정의할 것인가? (마지막 읽기 로그 기준)
- gRPC **unknown field 처리** 정책(무시 vs 에러)을 서비스별로 어떻게 통일할 것인가?
