### Q1. JSON vs Protocol Buffers vs Avro 어떤 것을 선택하나요?
A. JSON: 외부 API, 디버깅 용이, 스키마 약함. Protobuf: 내부 서비스, 크기↓, 전/후방 호환. Avro: 데이터 파이프라인, 스키마 레지스트리와 함께, 동적 스키마. 용도에 따라 혼합 사용 가능.

### Q2. 전방 호환(Forward)과 후방 호환(Backward)의 차이는?
A. 후방: 새 코드가 옛 데이터 읽기(새 필드에 기본값). 전방: 옛 코드가 새 데이터 읽기(모르는 필드 무시). 롤링 배포에서 둘 다 필요. 필드 추가는 optional+기본값으로 양방향 달성.

### Q3. 필드를 삭제해도 되나요?
A. 조심해야 함. 삭제된 필드의 태그 번호/이름 재사용 금지(옛 데이터와 충돌). 모든 소비자가 해당 필드를 안 쓴다고 확인될 때까지 deprecate 표시 후 오랜 기간 유지.

### Q4. 스키마 레지스트리란 무엇인가요?
A. 스키마 버전을 중앙에서 관리하는 서비스(Confluent Schema Registry 등). 생산자/소비자가 스키마 ID로 직렬화/역직렬화. 호환성 검증 자동화, 스키마 진화 추적.

### Q5. 롤링 배포 시 스키마 호환성이 왜 중요한가요?
A. 배포 중 신/구 버전 서버가 공존. 구 서버가 신 데이터, 신 서버가 구 데이터 처리해야 함. 호환성 없으면 역직렬화 실패, 데이터 손실, 장애 전파. 배포 전 호환성 검증 필수.

### Q6. REST API 버저닝 전략은?
A. URL 경로(/v1/orders), 헤더(Accept-Version: v2), 쿼리 파라미터(?version=2). 헤더가 깔끔하지만 테스트 어려움. 내부 API는 버저닝 최소화, 외부 API는 장기 지원 계획 필요.

### Q7. 타입 변경(예: int → string)은 가능한가요?
A. 대부분 위험. 일부 안전한 변환(int32→int64)만 가능. 타입 변경이 필요하면 새 필드 추가 → 마이그레이션 → 구 필드 제거 패턴 사용. 한 번에 바꾸면 호환성 깨짐.

### Q8. gRPC에서 unknown field는 어떻게 처리되나요?
A. Protobuf3는 기본적으로 unknown field 보존(라운드트립 안전). 하지만 일부 언어/버전에서 다름. 정책 통일 필요. 중간 프록시가 필드를 버리면 데이터 손실 가능.
