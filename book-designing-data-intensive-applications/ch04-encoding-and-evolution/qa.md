## 기초

### Q1. 직렬화 포맷을 왜 신중히 골라야 하나요?
A. 포맷은 서비스 간 계약이다. 한번 퍼진 계약은 장기간 유지되므로 크기, 성능, 진화 가능성을 함께 봐야 한다.

### Q2. Backward/Forward compatibility 차이는?
A. Backward는 새 코드가 옛 데이터를 읽는 능력, Forward는 옛 코드가 새 데이터를 견디는 능력이다. 롤링 배포에는 둘 다 중요하다.

### Q3. 스키마 레지스트리는 어떤 문제를 해결하나요?
A. 스키마 버전 난립과 비호환 배포를 막는다. 중앙 호환성 검증으로 장애를 사전에 차단한다.

## 실무

### Q4. 필드 삭제는 어떻게 진행해야 안전한가요?
A. 즉시 삭제 대신 deprecate 후 관측 기간을 둔다. 모든 소비자에서 사용 중단이 확인되면 제거하고, 번호/이름 재사용은 피한다.

### Q5. API 버저닝이 계속 늘어나는 상황은 어떻게 관리하나요?
A. 지원 종료 정책(EOL date)과 마이그레이션 가이드를 함께 운영한다. 버전 수를 조직 규칙으로 제한해야 유지 가능하다.

### Q6. 타입 변경이 필요하면 어떤 절차가 안전한가요?
A. 새 필드 추가, 이중 기록, 점진 전환, 구 필드 제거 순으로 간다. 한 번에 타입 치환하면 호환성 사고가 난다.

## 면접

### Q7. JSON이 디버깅에 좋다는 이유로 내부 고QPS 경로에도 JSON을 쓰는 판단은?
A. 운영 편의는 장점이지만 비용(대역폭/CPU)이 크다. 고QPS 내부 경로는 바이너리 포맷을 우선 검토하는 게 합리적이다.

### Q8. 스키마 호환성 실패를 CI에서 어떻게 막을 수 있나요?
A. 스키마 레지스트리 호환성 체크를 필수 파이프라인으로 넣고, 실패 시 배포 차단한다. 수동 리뷰만으로는 누락이 잦다.

### Q9. 데이터 계약(Data Contract)이 조직적으로 중요한 이유는?
A. 팀 경계를 넘는 변경 비용을 낮추기 때문이다. 계약이 명확하면 서비스 독립 배포와 장애 격리가 쉬워진다.
