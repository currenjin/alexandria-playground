# Ch03 Storage and Retrieval

## TL;DR (3문장)
- 스토리지 엔진은 **로그 기반(LSM-Tree)** 과 **페이지 기반(B-Tree)** 로 나뉜다. 쓰기 많으면 LSM, 읽기 많으면 B-Tree가 유리.
- **인덱스**는 읽기를 빠르게 하지만 **쓰기 증폭(Write Amplification)** 비용이 든다. 모든 쿼리 패턴을 인덱스로 커버할 수 없다.
- OLTP(트랜잭션)와 OLAP(분석)은 접근 패턴이 다르다. 열 지향 저장소, 압축, 머터리얼라이즈드 뷰로 분석 성능을 높인다.

## Key Ideas
- **해시 인덱스**: 메모리에 키→오프셋 매핑. 단순하고 빠르나, 범위 쿼리 불가, 메모리 한계.
- **SSTable/LSM-Tree**: 정렬된 세그먼트 파일 + 메모리 멤테이블 → 병합(Compaction). 쓰기 처리량↑, 읽기 시 여러 파일 탐색.
- **B-Tree**: 페이지 단위 읽기/쓰기, 균형 트리. 읽기 예측 가능, WAL로 내구성. 쓰기 증폭(페이지 분할, WAL).
- **Write Amplification**: 한 번 쓰기가 디스크에 여러 번 쓰기로 증폭. LSM(컴팩션), B-Tree(페이지+WAL) 둘 다 존재.
- **Compaction 전략**: Size-tiered(쓰기 최적화) vs Leveled(읽기/공간 최적화). 백그라운드 I/O 경쟁 주의.
- **클러스터드 인덱스**: 데이터를 인덱스 순서로 저장. 범위 스캔↑, 삽입 비용↑.
- **커버링 인덱스**: 인덱스만으로 쿼리 응답(힙 접근 없음). 인덱스 크기↑.
- **OLAP/열 저장소**: 컬럼별 저장 + 압축(비트맵, Run-length). 집계 쿼리↑, 단건 조회↓.
- **머터리얼라이즈드 뷰/데이터 큐브**: 미리 집계 저장. 쿼리 빠름, 쓰기 시 갱신 비용.

## Trade-offs
| 선택 | 장점 | 단점 | 언제 |
|---|---|---|---|
| **LSM-Tree** | 쓰기 처리량↑, 순차 I/O | 컴팩션 부하, 읽기 시 여러 파일 | 쓰기 많은 워크로드(로그, 이벤트) |
| **B-Tree** | 읽기 예측 가능, 범위 쿼리↑ | 쓰기 증폭(페이지+WAL), 조각화 | 읽기 많은 OLTP |
| **해시 인덱스** | O(1) 조회 | 범위 쿼리 불가, 메모리 한계 | 키-값 캐시, 세션 저장 |
| **클러스터드 인덱스** | 범위 스캔 지역성↑ | 삽입/갱신 비용↑, 공간↑ | 시계열, 로그, 범위 쿼리 주도 |
| **커버링 인덱스** | 힙 접근 제거, 읽기↑ | 인덱스 크기/쓰기↑ | 조회 컬럼 고정, 빈번한 쿼리 |
| **열 저장소** | 집계/스캔 효율↑, 압축↑ | 단건 조회/갱신 느림 | OLAP, 대시보드, 리포트 |
| **Size-tiered 컴팩션** | 쓰기 증폭↓ | 공간 증폭↑, 읽기 시 탐색↑ | 쓰기 우선 |
| **Leveled 컴팩션** | 읽기↑, 공간↓ | 쓰기 증폭↑ | 읽기 우선, 공간 제약 |

## Apply to Our Domain (Orders/Dispatch)
- **주문 테이블(OLTP)**: B-Tree 기반 RDB. `(user_id, created_at DESC)` 클러스터드/커버링 인덱스로 최근 주문 목록 최적화.
- **이벤트 로그/감사**: LSM-Tree 기반 저장소(Cassandra, RocksDB). 시간순 쓰기 많음, 읽기는 드묾.
- **주문 분석(OLAP)**: 열 저장소(BigQuery, ClickHouse)로 일별/주별 집계. 실시간 대시보드는 머터리얼라이즈드 뷰.
- **nearbyBaseOrderId 탐색**: 키셋 페이징 + `(created_at DESC, id DESC)` 복합 인덱스. 커버링 인덱스로 힙 접근 최소화.
- **캐시 레이어**: Redis 해시 인덱스로 핫 키(주문 상세) O(1) 조회.

## Metrics & SLO (30일 롤링)
### SLI
- `db.query.p95_ms`: 주요 쿼리 응답 시간
- `db.index_hit_rate`: 인덱스 히트율(인덱스 스캔 vs 풀 스캔)
- `db.write_amplification`: 논리 쓰기 대비 물리 쓰기 비율
- `compaction.pending_bytes`: 컴팩션 대기 데이터 크기
- `olap.query.p95_s`: 분석 쿼리 응답 시간

### SLO
- `db.query.p95_ms < 100` (OLTP 핵심 경로)
- `db.index_hit_rate >= 98%`
- `compaction.pending_bytes < 1GB` (지연 경고)
- `olap.query.p95_s < 5` (대시보드 쿼리)

## Open Questions
- LSM-Tree 스토리지 도입 시 **컴팩션 스케줄**을 피크 시간 외로 제한할 수 있는가?
- 커버링 인덱스 추가로 인한 **쓰기 증폭**이 현재 쓰기 QPS에서 수용 가능한가?
- 분석 워크로드를 별도 열 저장소로 분리할 때 **ETL 지연**과 **데이터 신선도** 요구사항은?
- 해시 인덱스(Redis) 메모리 한계 도달 시 **eviction 정책**과 **캐시 miss 스파이크** 대응은?
