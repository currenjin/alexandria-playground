### Q1. LSM-Tree와 B-Tree 중 어떤 것을 선택해야 하나요?
A. LSM-Tree: 쓰기 많은 워크로드(로그, 이벤트, 시계열). B-Tree: 읽기 많은 OLTP, 범위 쿼리 중요. 혼합이면 워크로드 비율로 판단. 대부분의 RDB는 B-Tree, Cassandra/RocksDB는 LSM.

### Q2. Write Amplification이란 무엇인가요?
A. 논리적 1회 쓰기가 물리적으로 여러 번 쓰이는 현상. LSM: 컴팩션으로 데이터 재작성. B-Tree: 페이지 분할 + WAL 이중 기록. SSD 수명, I/O 비용에 영향. 워크로드에 따라 트레이드오프.

### Q3. Compaction 전략(Size-tiered vs Leveled)은 어떻게 선택하나요?
A. Size-tiered: 쓰기 최적화, 공간 증폭↑, 읽기 시 여러 파일 탐색. Leveled: 읽기/공간 최적화, 쓰기 증폭↑. 공간 제약 있거나 읽기 중요하면 Leveled, 쓰기 처리량 우선이면 Size-tiered.

### Q4. 클러스터드 인덱스 vs 논클러스터드 인덱스 차이는?
A. 클러스터드: 데이터가 인덱스 순서로 물리 저장. 테이블당 1개. 범위 스캔↑. 논클러스터드: 인덱스가 데이터 위치(RID/PK) 참조. 여러 개 가능. 클러스터드는 삽입 위치 고정 → 삽입 비용↑.

### Q5. 왜 OLTP와 OLAP를 분리하나요?
A. 접근 패턴이 정반대. OLTP: 소수 행, 빈번한 읽기/쓰기, 낮은 지연. OLAP: 대량 행 스캔, 집계, 높은 처리량. 같은 DB에서 돌리면 서로 방해. 열 저장소, 압축, 별도 인프라로 분리.

### Q6. 인덱스만 추가하면 모든 쿼리가 빨라지나요?
A. 아님. 인덱스는 선택도(Cardinality)가 높을 때 효과적. 성별(M/F)처럼 값이 적으면 풀 스캔이 더 빠를 수 있음. 또한 쿼리 조건이 인덱스 선두 컬럼을 포함해야 활용됨.

### Q7. 해시 인덱스의 한계는?
A. 범위 쿼리 불가(=만 가능), 메모리에 전체 키 보유 필요, 정렬 불가. 단순 키-값 조회에만 적합. 대부분의 DB는 B-Tree를 기본으로 쓰고, 해시는 특수 용도(Redis, 메모리 해시맵).

### Q8. 머터리얼라이즈드 뷰는 언제 쓰나요?
A. 자주 사용되는 집계/조인 결과를 미리 계산해 저장. 읽기↑, 쓰기 시 갱신 비용↑. 데이터 변경 적고 집계 쿼리 빈번할 때 유용. 실시간성 요구되면 갱신 주기 주의.
