## 기초

### Q1. LSM-Tree와 B-Tree의 본질적 차이는?
A. LSM은 순차 쓰기와 컴팩션 중심, B-Tree는 제자리 업데이트와 페이지 탐색 중심이다. 전자는 쓰기, 후자는 읽기/범위조회에 강한 경향이 있다.

### Q2. Write Amplification이 왜 문제인가요?
A. 논리적 1회 쓰기가 물리적으로 여러 번 기록되면 I/O 비용과 저장장치 수명이 악화된다. 고쓰기 워크로드에서 특히 치명적이다.

### Q3. OLTP와 OLAP를 분리하는 이유는?
A. 트랜잭션 처리와 대규모 분석의 접근 패턴이 다르기 때문이다. 하나의 저장소에서 둘을 같이 돌리면 상호 간섭이 커진다.

## 실무

### Q4. 컴팩션 전략은 어떻게 고르나요?
A. 쓰기 처리량 우선이면 size-tiered, 조회/공간 효율 우선이면 leveled를 고려한다. 실제 데이터 분포로 벤치마크해 결정해야 한다.

### Q5. 클러스터드 인덱스 PK 선택 시 주의점은?
A. 삽입 순서가 랜덤이면 페이지 분할이 증가한다. 가능하면 단조 증가 키를 고려하고, 도메인 요구상 랜덤 키를 쓰면 보조 전략(버퍼, fill factor)을 둔다.

### Q6. 머터리얼라이즈드 뷰 운영에서 자주 터지는 문제는?
A. 갱신 지연과 재계산 비용이다. 최신성이 중요한지, 계산비 절감이 중요한지 기준을 먼저 정해야 한다.

## 면접

### Q7. "LSM이 최신이라 B-Tree를 대체한다"는 말의 문제점은?
A. 워크로드 차이를 무시한 주장이다. 읽기 지연, 범위 조회, 운영 단순성에서 B-Tree가 여전히 강하다.

### Q8. 저장 엔진 선택을 한 줄로 설명해보세요.
A. "우리 워크로드의 read/write 비율, 범위조회 빈도, 허용 지연을 기준으로 총비용이 가장 낮은 엔진을 고른다."가 핵심이다.

### Q9. 캐시를 넣기 전에 반드시 확인할 것은?
A. 근본 병목이 저장 엔진/쿼리 설계인지 먼저 확인해야 한다. 잘못된 캐시는 일시 봉합일 뿐, 정합성과 운영 복잡도만 늘릴 수 있다.
