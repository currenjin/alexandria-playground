## 기초

### Q1. Reliability와 Availability의 차이는?
A. Reliability는 "올바르게 동작하는가", Availability는 "응답 가능한가"다. 빠르게 응답해도 잘못된 결과면 신뢰성이 낮다.

### Q2. 왜 평균 대신 p95/p99를 보나요?
A. 평균은 느린 소수 요청을 숨긴다. 사용자 불만은 주로 tail latency(p95/p99)에서 발생하므로 운영 판단은 tail 중심이 맞다.

### Q3. Fault와 Failure는 어떻게 다른가?
A. Fault는 내부 구성요소의 이상, Failure는 사용자 관점의 기능 실패다. 설계 목표는 fault가 failure로 전파되지 않게 만드는 것이다.

## 실무

### Q4. SLO는 어떻게 시작하면 되나요?
A. 핵심 사용자 경로 1~2개부터 SLI를 정하고, 현재 성능 기반으로 현실적인 목표치를 둔다. 이후 에러 버짓으로 배포 속도와 안정성 균형을 맞춘다.

### Q5. 수평 확장에서 가장 먼저 점검할 것은?
A. 상태 보관 위치다. 세션/캐시/DB 키 분산 전략 없이 인스턴스만 늘리면 병목이 데이터 계층으로 이동한다.

### Q6. 비동기 처리를 늘릴 때 필수로 같이 넣어야 하는 것은?
A. 재시도 정책, DLQ, 추적 가능한 상관관계 ID다. 셋이 없으면 실패 원인 분석과 복구가 거의 불가능해진다.

## 면접

### Q7. "가용성을 올리면 신뢰성이 떨어질 수 있다"를 설명해보세요.
A. 타임아웃을 매우 짧게 잡으면 빠르게 실패 응답은 가능해 가용성 지표가 좋아 보일 수 있다. 하지만 정상 처리 가능한 요청까지 실패 처리하면 신뢰성은 떨어진다.

### Q8. 에러 버짓이 0%인 상태에서 기능 출시 요청이 오면?
A. 신규 배포를 제한하고 안정화 작업(장애 원인 제거, 롤백 자동화, 관측성 개선)을 우선한다. 에러 버짓을 운영 의사결정 규칙으로 강제해야 한다.

### Q9. "단순성이 성능보다 중요하다"는 주장에 대한 의견은?
A. 초기/중간 규모에서는 대체로 맞다. 단순성은 장애 복구와 변경 속도를 높여 총비용을 낮춘다. 단, 명백한 병목 구간은 측정 기반으로 선택적 최적화가 필요하다.
